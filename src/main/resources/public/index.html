<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Rivers & Roses Command Center</title>
    <style>
      :root {
        --bg: #0d1117;
        --panel: #161b22;
        --border: #30363d;
        --text: #c9d1d9;
        --accent: #388bfd;
      }
      body {
        margin: 0;
        background-color: var(--bg);
        color: var(--text);
        font-family: "Segoe UI", monospace;
        overflow: hidden;
        display: flex;
        height: 100vh;
      }

      /* Layout */
      #game-view {
        flex-grow: 1;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #010409;
      }
      #sidebar {
        width: 300px;
        background: var(--panel);
        border-left: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        padding: 10px;
        box-sizing: border-box;
        overflow-y: auto;
      }

      /* Canvas */
      canvas {
        background-color: #0d1117;
        border: 1px solid var(--border);
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        cursor: crosshair;
      }

      /* UI Components */
      h2,
      h3 {
        margin: 0 0 10px 0;
        color: #fff;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 1px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 5px;
      }
      .section {
        margin-bottom: 20px;
      }

      .btn {
        background: var(--border);
        color: #fff;
        border: none;
        padding: 6px 12px;
        cursor: pointer;
        border-radius: 4px;
        font-size: 12px;
        transition: 0.2s;
        width: 100%;
        margin-bottom: 5px;
      }
      .btn:hover {
        background: var(--accent);
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.red {
        background: #da3633;
      }
      .btn.red:hover {
        background: #f85149;
      }

      input {
        background: #0d1117;
        border: 1px solid var(--border);
        color: #fff;
        padding: 5px;
        width: 100%;
        box-sizing: border-box;
        margin-bottom: 5px;
      }

      /* Ship List */
      #my-ships {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .ship-item {
        padding: 8px;
        border: 1px solid var(--border);
        margin-bottom: 5px;
        cursor: pointer;
        border-radius: 4px;
        font-size: 12px;
      }
      .ship-item:hover {
        background: #21262d;
      }
      .ship-item.active {
        border-color: var(--accent);
        background: rgba(56, 139, 253, 0.1);
      }
      .ship-status {
        font-size: 10px;
        color: #8b949e;
        display: flex;
        justify-content: space-between;
        margin-top: 4px;
      }

      /* Log */
      #log {
        font-family: "Courier New", monospace;
        font-size: 10px;
        height: 150px;
        overflow-y: auto;
        color: #8b949e;
        border-top: 1px solid var(--border);
        padding-top: 10px;
      }
      .log-entry {
        margin-bottom: 2px;
      }
      .log-success {
        color: #3fb950;
      }
      .log-error {
        color: #f85149;
      }

      /* Toast */
      #toast {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--accent);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s;
      }

      /* Leaderboard Styling */
      #leaderboard-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .lb-item {
        display: flex;
        justify-content: space-between;
        padding: 4px 8px;
        border-bottom: 1px solid #21262d;
        font-size: 11px;
      }
      .lb-item:last-child {
        border-bottom: none;
      }
      .lb-rank {
        width: 20px;
        color: #8b949e;
        font-weight: bold;
      }
      .lb-name {
        flex-grow: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-right: 10px;
      }
      .lb-score {
        color: #e3b341;
        font-family: monospace;
      }

      /* Podium Colors */
      .lb-item.rank-1 .lb-rank {
        color: #f2cc60;
      }
      .lb-item.rank-2 .lb-rank {
        color: #c0c0c0;
      }
      .lb-item.rank-3 .lb-rank {
        color: #cd7f32;
      }
      .lb-item.rank-1 .lb-name {
        color: #f2cc60;
      }
    </style>
  </head>
  <body>
    <div id="game-view">
      <div id="toast">Command Sent</div>
      <canvas id="worldCanvas"></canvas>
      <div
        style="
          position: absolute;
          bottom: 10px;
          left: 10px;
          font-size: 10px;
          color: #8b949e;
        "
      >
        Left Click: Select Point &bull; Right Click: Move Selected Ship
      </div>
    </div>

    <div id="sidebar">
      <div class="section">
        <h2>Sector Leaderboard</h2>
        <ul id="leaderboard-list"></ul>
      </div>

      <div class="section">
        <h2>Register New Ship</h2>
        <input
          type="text"
          id="reg-team"
          placeholder="Team Name (e.g. RedLeader)"
        />
        <button class="btn" onclick="registerShip()">Spawn Ship</button>
      </div>

      <div class="section">
        <h2>My Fleet</h2>
        <div
          id="no-ships-msg"
          style="font-size: 11px; color: #666; margin-bottom: 5px"
        >
          No ships under command.
        </div>
        <ul id="my-ships"></ul>
      </div>

      <div class="section">
        <h2>Ship Controls</h2>

        <div
          style="
            background: #21262d;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
          "
        >
          <div style="font-size: 11px; margin-bottom: 4px; color: #8b949e">
            RADAR (Costs Fuel!)
          </div>
          <div style="display: flex; gap: 5px">
            <input
              type="number"
              id="scan-radius"
              value="200"
              min="50"
              max="800"
              style="width: 60px"
              placeholder="Radius"
            />
            <button
              class="btn"
              style="width: auto; flex-grow: 1"
              onclick="performManualScan()"
            >
              SCAN AREA
            </button>
          </div>
        </div>

        <div style="font-size: 11px; margin-bottom: 5px">
          Speed Setting: <span id="speed-val">50</span>
        </div>
        <input
          type="range"
          id="speed-slider"
          min="0"
          max="100"
          value="50"
          oninput="document.getElementById('speed-val').innerText = this.value"
        />

        <div
          style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
          "
        >
          <button class="btn" onclick="sendRefill()">Refill Fuel</button>
          <button class="btn" onclick="sendUnload()">Unload Cargo</button>
          <button class="btn" onclick="sendConfig(true)">AutoCollect ON</button>
          <button class="btn" onclick="sendConfig(false)">
            AutoCollect OFF
          </button>
        </div>
        <button class="btn red" style="margin-top: 5px" onclick="sendDump()">
          Dump Cargo (Emergency)
        </button>
      </div>

      <div id="log"></div>
    </div>

    <script>
      // STATE
      const GAME_CONFIG = { width: 1000, height: 1000 };
      let worldData = null;

      // Local fleet storage: Token -> {id, team}
      let myFleet = JSON.parse(localStorage.getItem("rivers_fleet")) || {};
      let selectedToken = null;

      // Fog of War: Resources found via scan
      const knownResources = new Map();

      let leaderboardData = [];
      let ws = null;

      // Fast lookup maps for applying deltas
      const worldIndex = {
        shipsById: new Map(),
        missionsById: new Map(),
        stationsById: new Map(),
      };

      // --- OPTIMISTIC RENDER STATE (dead-reckoning) ---
      // shipId -> {
      //    shipId, teamName, fuel, headingDeg, speed,
      //    serverX, serverY, serverAtMs,
      //    x, y (rendered)
      // }
      const renderShips = new Map();

      // Tuning
      const MAX_PREDICT_SECONDS = 1.2; // clamp (prevents huge leaps if tab lags)
      const SNAP_ERROR = 120; // if server disagrees by more than this, snap

      function nowMs() {
        return performance.now();
      }

      // headingDeg: 0 = up, 90 = right
      function headingToDir(headingDeg) {
        const a = (headingDeg * Math.PI) / 180;
        return { vx: Math.sin(a), vy: -Math.cos(a) };
      }

      function upsertShipFromServer(s) {
        const t = nowMs();

        worldIndex.shipsById.set(s.shipId, s);

        const r = renderShips.get(s.shipId);
        if (!r) {
          renderShips.set(s.shipId, {
            shipId: s.shipId,
            teamName: s.teamName,
            fuel: s.fuel,
            headingDeg: s.headingDeg,
            speed: s.speed,
            serverX: s.x,
            serverY: s.y,
            serverAtMs: t,
            x: s.x,
            y: s.y,
          });
          return;
        }

        // Update metadata
        r.teamName = s.teamName;
        r.fuel = s.fuel;
        r.headingDeg = s.headingDeg;
        r.speed = s.speed;

        // Compute current predicted pos from old anchor to see how far off
        const dtOld = Math.min(
          MAX_PREDICT_SECONDS,
          Math.max(0, (t - r.serverAtMs) / 1000),
        );
        const dirOld = headingToDir(r.headingDeg || 0);
        const predOldX = r.serverX + dirOld.vx * (r.speed || 0) * dtOld;
        const predOldY = r.serverY + dirOld.vy * (r.speed || 0) * dtOld;

        const err = Math.hypot(s.x - predOldX, s.y - predOldY);

        // Reset anchor to the new authoritative point/time
        r.serverX = s.x;
        r.serverY = s.y;
        r.serverAtMs = t;

        // If we way off (respawn / collision / missed updates), snap render too.
        // Otherwise: do nothing, dead-reckoning fixes itself
        if (err > SNAP_ERROR) {
          r.x = s.x;
          r.y = s.y;
        }
      }

      function updateOptimisticShips() {
        const t = nowMs();

        for (const r of renderShips.values()) {
          const dt = Math.min(
            MAX_PREDICT_SECONDS,
            Math.max(0, (t - r.serverAtMs) / 1000),
          );
          const dir = headingToDir(r.headingDeg || 0);

          const predX = r.serverX + dir.vx * (r.speed || 0) * dt;
          const predY = r.serverY + dir.vy * (r.speed || 0) * dt;

          r.x = Math.max(0, Math.min(GAME_CONFIG.width, predX));
          r.y = Math.max(0, Math.min(GAME_CONFIG.height, predY));
        }
      }

      function getRenderedShipsArray() {
        return Array.from(renderShips.values()).map((r) => ({
          shipId: r.shipId,
          teamName: r.teamName,
          x: r.x,
          y: r.y,
          headingDeg: r.headingDeg,
          speed: r.speed,
          fuel: r.fuel,
        }));
      }

      // CANVAS
      const canvas = document.getElementById("worldCanvas");
      const ctx = canvas.getContext("2d");
      let scaleFactor = 1.0;

      function resize() {
        const size = Math.min(window.innerWidth, window.innerHeight) - 40;
        canvas.width = size;
        canvas.height = size;
        scaleFactor = size / GAME_CONFIG.width;
        render();
      }
      window.addEventListener("resize", resize);

      // LOGGING
      function log(msg, type = "normal") {
        const div = document.createElement("div");
        div.className =
          "log-entry " +
          (type === "error"
            ? "log-error"
            : type === "success"
              ? "log-success"
              : "");
        div.innerText = `> ${msg}`;
        const logBox = document.getElementById("log");
        logBox.prepend(div);
      }

      // API CALLS
      async function registerShip() {
        const team = document.getElementById("reg-team").value || "Anon";
        const token = "cmd-" + Math.random().toString(36).substr(2, 9);

        try {
          const res = await fetch("/ships/register", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ token: token, teamName: team }),
          });

          if (res.ok) {
            const data = await res.json();
            myFleet[token] = { id: data.shipId, team: team };
            localStorage.setItem("rivers_fleet", JSON.stringify(myFleet));
            log(`Registered ${team}`, "success");
            renderFleetList();
            selectShip(token);
          } else {
            const err = await safeJson(res);
            log(`Registration failed: ${err?.message || res.status}`, "error");
          }
        } catch (e) {
          log("Net error: " + e.message, "error");
        }
      }

      async function setCourse(x, y) {
        if (!selectedToken) {
          log("No ship selected!", "error");
          return;
        }
        const speed = parseInt(document.getElementById("speed-slider").value);

        showToast(`Moving to ${Math.round(x)},${Math.round(y)}`);

        // small hack for smoother rendering on new command; reset prediction clock
        const shipId = myFleet[selectedToken]?.id;
        if (shipId && renderShips.has(shipId)) {
          const r = renderShips.get(shipId);
          r.serverX = r.x;
          r.serverY = r.y;
          r.serverAtMs = nowMs();
          r.speed = speed;
        }

        await fetch("/ships/me/course", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Token": selectedToken,
          },
          body: JSON.stringify({ targetX: x, targetY: y, speed: speed }),
        });
      }

      async function sendRefill() {
        if (!selectedToken) return;
        await fetch("/ships/me/refill", {
          method: "POST",
          headers: { "X-Token": selectedToken },
        });
        log("Refill command sent");
      }

      async function performManualScan() {
        if (!selectedToken) {
          log("Select a ship first!", "error");
          return;
        }

        const radius = document.getElementById("scan-radius").value;

        try {
          showToast("Scanning...");
          const res = await fetch(`/scan?radius=${radius}`, {
            method: "GET",
            headers: { "X-Token": selectedToken },
          });

          if (res.ok) {
            const data = await res.json();

            let count = 0;
            if (data.resources) {
              data.resources.forEach((r) => {
                knownResources.set(r.id, r);
                count++;
              });
            }
            log(`Scan complete. Found ${count} resources.`, "success");
            render();
          } else {
            log("Scan failed (Low Fuel?)", "error");
          }
        } catch (e) {
          log("Net error: " + e.message, "error");
        }
      }

      async function sendUnload() {
        if (!selectedToken) return;
        const res = await fetch("/ships/me/unload", {
          method: "POST",
          headers: { "X-Token": selectedToken },
        });

        if (res.ok) {
          const data = await res.json();
          const items = data.items ?? data.itemsSold ?? 0;
          const value = data.value ?? data.earned ?? 0;
          const total = data.totalCredits ?? data.credits ?? null;
          log(
            `Sold ${items} items for $${value}` +
              (total != null ? ` (Total: $${total})` : ""),
            "success",
          );
        } else {
          const err = await safeJson(res);
          log(`Unload fail: ${err?.message || res.status}`, "error");
        }
      }

      async function sendDump() {
        if (!selectedToken) return;
        if (confirm("Dump all cargo into space?")) {
          await fetch("/ships/me/dump", {
            method: "POST",
            headers: { "X-Token": selectedToken },
          });
          log("Cargo dumped");
        }
      }

      async function sendConfig(autoCollect) {
        if (!selectedToken) return;
        await fetch("/ships/me/config", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Token": selectedToken,
          },
          body: JSON.stringify({ autoCollect: autoCollect }),
        });
        log(`AutoCollect set to ${autoCollect}`);
      }

      async function fetchLeaderboard() {
        try {
          const res = await fetch("/leaderboard");
          if (res.ok) {
            leaderboardData = await res.json();
            renderLeaderboard();
          }
        } catch (e) {}
      }

      async function fetchInitialSnapshotFallback() {
        try {
          const response = await fetch("/world/snapshot");
          if (response.ok) {
            const snap = await response.json();
            applySnapshot(snap);
          }
        } catch (e) {}
      }

      async function safeJson(res) {
        try {
          return await res.json();
        } catch {
          return null;
        }
      }

      // WEBSOCKET WORLD STREAMING
      function connectWorldWs() {
        const proto = window.location.protocol === "https:" ? "wss" : "ws";
        const url = `${proto}://${window.location.host}/ws/world`;

        ws = new WebSocket(url);

        ws.onopen = () => log("World connected!", "success");

        ws.onclose = () => {
          log("World stream disconnected, retrying...", "error");
          setTimeout(connectWorldWs, 1500);
        };

        ws.onmessage = (evt) => {
          let msg;
          try {
            msg = JSON.parse(evt.data);
          } catch {
            return;
          }
          if (!msg || !msg.type) return;

          if (msg.type === "snapshot") applySnapshot(msg.payload);
          else if (msg.type === "delta") applyDelta(msg.payload);
        };
      }

      function applySnapshot(snap) {
        worldData = {
          width: snap.width ?? 1000,
          height: snap.height ?? 1000,
          homeX: snap.homeX ?? 500,
          homeY: snap.homeY ?? 500,
          refillRadius: snap.refillRadius ?? 40,
          ships: snap.ships || [],
          stations: snap.stations || [],
          missions: snap.missions || [],
          resources: [], // Kept empty, used from memory
        };

        GAME_CONFIG.width = worldData.width || 1000;
        GAME_CONFIG.height = worldData.height || 1000;

        rebuildIndexes();

        const seen = new Set();
        for (const s of worldData.ships) {
          seen.add(s.shipId);
          upsertShipFromServer(s);
        }
        for (const id of Array.from(renderShips.keys())) {
          if (!seen.has(id)) renderShips.delete(id);
        }

        if (Math.abs(canvas.width / scaleFactor - GAME_CONFIG.width) > 1)
          resize();
        renderFleetList();
      }

      function rebuildIndexes() {
        worldIndex.shipsById.clear();
        worldIndex.missionsById.clear();
        worldIndex.stationsById.clear();

        for (const s of worldData.ships) worldIndex.shipsById.set(s.shipId, s);
        for (const m of worldData.missions)
          worldIndex.missionsById.set(m.id, m);
        for (const st of worldData.stations)
          worldIndex.stationsById.set(st.id, st);
      }

      function applyDelta(delta) {
        if (!worldData) return;
        const ops = delta.ops || [];
        if (ops.length === 0) return;

        for (const op of ops) {
          if (op.ship) {
            upsertShipFromServer(op.ship);
          } else if (op.mission) {
            worldIndex.missionsById.set(op.mission.id, op.mission);
          } else if (op.id && !op.oreId && !op.value && !op.x && !op.y) {
            worldIndex.missionsById.delete(op.id);
            // We can optionally remove from knownResources if we knew it was gone,
            // but for simple Fog of War, we often leave it until re-scanned.
            knownResources.delete(op.id);
          }
        }

        worldData.ships = Array.from(worldIndex.shipsById.values());
        worldData.missions = Array.from(worldIndex.missionsById.values());
      }

      // GAME LOOP
      function loop() {
        updateOptimisticShips();
        render();
        requestAnimationFrame(loop);
      }

      setInterval(fetchLeaderboard, 2000);

      // init
      resize();
      renderFleetList();
      fetchInitialSnapshotFallback();
      connectWorldWs();
      loop();

      // UI LOGIC
      function renderLeaderboard() {
        const list = document.getElementById("leaderboard-list");

        if (!leaderboardData || leaderboardData.length === 0) {
          list.innerHTML =
            '<li style="padding:5px; color:#666; font-style:italic; font-size:11px;">No data</li>';
          return;
        }

        list.innerHTML = "";

        const myTeamNames = Object.values(myFleet).map((s) => s.team);

        leaderboardData.forEach((entry, index) => {
          const rank = index + 1;
          const li = document.createElement("li");
          li.className = `lb-item rank-${rank}`;

          if (myTeamNames.includes(entry.team))
            li.style.background = "rgba(56, 139, 253, 0.1)";

          li.innerHTML = `
            <span class="lb-rank">#${rank}</span>
            <span class="lb-name">${entry.team}</span>
            <span class="lb-score">$${entry.score}</span>
          `;
          list.appendChild(li);
        });
      }

      function renderFleetList() {
        const list = document.getElementById("my-ships");
        list.innerHTML = "";
        const keys = Object.keys(myFleet);

        document.getElementById("no-ships-msg").style.display =
          keys.length === 0 ? "block" : "none";

        keys.forEach((token) => {
          const shipInfo = myFleet[token];
          const li = document.createElement("li");
          li.className =
            "ship-item " + (selectedToken === token ? "active" : "");
          li.onclick = () => selectShip(token);

          let liveInfo = "Offline";
          let fuel = 0;

          const r = renderShips.get(shipInfo.id);
          if (r) {
            liveInfo = `(${Math.round(r.x)}, ${Math.round(r.y)})`;
            fuel = Math.round(r.fuel || 0);
          }

          li.innerHTML = `
            <div><strong>${shipInfo.team}</strong></div>
            <div class="ship-status">
              <span>${liveInfo}</span>
              <span>Fuel: ${fuel}</span>
            </div>
          `;
          list.appendChild(li);
        });
      }

      function selectShip(token) {
        selectedToken = token;
        renderFleetList();
      }

      function showToast(msg) {
        const t = document.getElementById("toast");
        t.innerText = msg;
        t.style.opacity = "1";
        setTimeout(() => (t.style.opacity = "0"), 2000);
      }

      // INPUT HANDLING
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / scaleFactor;
        const y = (e.clientY - rect.top) / scaleFactor;
        setCourse(x, y);
      });

      // RENDERING
      function render() {
        ctx.fillStyle = "#010409";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawGrid();

        if (!worldData) {
          ctx.fillStyle = "white";
          ctx.fillText("Connecting...", 20, 20);
          return;
        }

        drawBase(worldData.homeX, worldData.homeY, worldData.refillRadius);

        for (const st of worldData.stations || []) {
          const dx = st.x - worldData.homeX;
          const dy = st.y - worldData.homeY;
          if (Math.hypot(dx, dy) < 5) continue;
          drawStation(st);
        }

        (worldData.missions || []).forEach(drawMission);

        // Draw Known Resources (Fog of War)
        knownResources.forEach(drawResource);

        const shipsToDraw = getRenderedShipsArray();

        shipsToDraw.forEach((s) => {
          const isMine = Object.values(myFleet).some((f) => f.id === s.shipId);
          const isSelected =
            selectedToken &&
            myFleet[selectedToken] &&
            myFleet[selectedToken].id === s.shipId;
          drawShip(s, isMine, isSelected);
        });

        if (Math.random() < 0.08) renderFleetList();
      }

      function drawGrid() {
        ctx.strokeStyle = "#161b22";
        ctx.lineWidth = 1;
        const step = 100 * scaleFactor;
        ctx.beginPath();
        for (let i = 0; i < canvas.width; i += step) {
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
        }
        for (let i = 0; i < canvas.height; i += step) {
          ctx.moveTo(0, i);
          ctx.lineTo(canvas.width, i);
        }
        ctx.stroke();
      }

      function drawBase(x, y, r) {
        const sX = x * scaleFactor,
          sY = y * scaleFactor,
          sR = r * scaleFactor;
        ctx.strokeStyle = "#388bfd";
        ctx.fillStyle = "rgba(56, 139, 253, 0.05)";
        ctx.beginPath();
        ctx.arc(sX, sY, sR, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = "#388bfd";
        ctx.fillText("BASE", sX - 12, sY - 5);
      }

      function drawStation(st) {
        const sX = st.x * scaleFactor;
        const sY = st.y * scaleFactor;

        ctx.fillStyle = "#8b949e";
        ctx.fillRect(sX - 4, sY - 4, 8, 8);

        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.font = "10px monospace";
        ctx.textAlign = "center";
        ctx.fillText(st.name || "Station", sX, sY - 8);
        ctx.textAlign = "start";
      }

      function drawMission(m) {
        const pulse = (Math.sin(Date.now() / 150) + 1) * 3;
        ctx.strokeStyle = "#d2a8ff";
        ctx.beginPath();
        ctx.arc(
          m.x * scaleFactor,
          m.y * scaleFactor,
          4 + pulse,
          0,
          Math.PI * 2,
        );
        ctx.stroke();
      }

      function drawResource(r) {
        const ore = (r.oreId || r.type || "").toUpperCase();

        let c = "#fff";
        if (ore === "IRON") c = "#a371f7";
        if (ore === "GOLD") c = "#e3b341";
        if (ore === "DIAMOND") c = "#58a6ff";
        if (ore.startsWith("CRATE")) c = "#3fb950";

        ctx.fillStyle = c;
        ctx.beginPath();
        ctx.arc(r.x * scaleFactor, r.y * scaleFactor, 3, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawShip(s, isMine, isSelected) {
        const x = s.x * scaleFactor,
          y = s.y * scaleFactor;

        ctx.save();
        ctx.translate(x, y);

        if (isSelected) {
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(0, 0, 10, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.fillStyle = isMine ? "#58a6ff" : "#8b949e";
        ctx.font = "10px monospace";
        ctx.fillText(s.teamName, 12, 3);

        ctx.rotate((s.headingDeg * Math.PI) / 180);

        ctx.fillStyle = isMine ? "#388bfd" : "#8b949e";
        if (isSelected) ctx.fillStyle = "#ffffff";

        ctx.beginPath();
        ctx.moveTo(0, -8);
        ctx.lineTo(6, 6);
        ctx.lineTo(0, 3);
        ctx.lineTo(-6, 6);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }
    </script>
  </body>
</html>
